{"mappings":"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G,CAC9H,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAC9H,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAC9H,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAC9H,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAC9H,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAAG,EAAG,CAAE,CAAE,EAAG,EAAG,EAA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","sources":["<anon>","src/js/worker.js","node_modules/three/examples/jsm/math/SimplexNoise.js"],"sourcesContent":["(() => {\nvar $6b3c5da8d6be8646$exports = {};\n// worker.js\n// Ported from Stefan Gustavson's java implementation\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n// Read Stefan's excellent paper for details on how this code works.\n//\n// Sean McCullough banksean@gmail.com\n//\n// Added 4D noise\n/**\n * You can pass in a random number generator object if you like.\n * It is assumed to have a random() method.\n */ class $2450539c160c7a52$export$7cef8d54b4fb09be {\n    constructor(r = Math){\n        this.grad3 = [\n            [\n                1,\n                1,\n                0\n            ],\n            [\n                -1,\n                1,\n                0\n            ],\n            [\n                1,\n                -1,\n                0\n            ],\n            [\n                -1,\n                -1,\n                0\n            ],\n            [\n                1,\n                0,\n                1\n            ],\n            [\n                -1,\n                0,\n                1\n            ],\n            [\n                1,\n                0,\n                -1\n            ],\n            [\n                -1,\n                0,\n                -1\n            ],\n            [\n                0,\n                1,\n                1\n            ],\n            [\n                0,\n                -1,\n                1\n            ],\n            [\n                0,\n                1,\n                -1\n            ],\n            [\n                0,\n                -1,\n                -1\n            ]\n        ];\n        this.grad4 = [\n            [\n                0,\n                1,\n                1,\n                1\n            ],\n            [\n                0,\n                1,\n                1,\n                -1\n            ],\n            [\n                0,\n                1,\n                -1,\n                1\n            ],\n            [\n                0,\n                1,\n                -1,\n                -1\n            ],\n            [\n                0,\n                -1,\n                1,\n                1\n            ],\n            [\n                0,\n                -1,\n                1,\n                -1\n            ],\n            [\n                0,\n                -1,\n                -1,\n                1\n            ],\n            [\n                0,\n                -1,\n                -1,\n                -1\n            ],\n            [\n                1,\n                0,\n                1,\n                1\n            ],\n            [\n                1,\n                0,\n                1,\n                -1\n            ],\n            [\n                1,\n                0,\n                -1,\n                1\n            ],\n            [\n                1,\n                0,\n                -1,\n                -1\n            ],\n            [\n                -1,\n                0,\n                1,\n                1\n            ],\n            [\n                -1,\n                0,\n                1,\n                -1\n            ],\n            [\n                -1,\n                0,\n                -1,\n                1\n            ],\n            [\n                -1,\n                0,\n                -1,\n                -1\n            ],\n            [\n                1,\n                1,\n                0,\n                1\n            ],\n            [\n                1,\n                1,\n                0,\n                -1\n            ],\n            [\n                1,\n                -1,\n                0,\n                1\n            ],\n            [\n                1,\n                -1,\n                0,\n                -1\n            ],\n            [\n                -1,\n                1,\n                0,\n                1\n            ],\n            [\n                -1,\n                1,\n                0,\n                -1\n            ],\n            [\n                -1,\n                -1,\n                0,\n                1\n            ],\n            [\n                -1,\n                -1,\n                0,\n                -1\n            ],\n            [\n                1,\n                1,\n                1,\n                0\n            ],\n            [\n                1,\n                1,\n                -1,\n                0\n            ],\n            [\n                1,\n                -1,\n                1,\n                0\n            ],\n            [\n                1,\n                -1,\n                -1,\n                0\n            ],\n            [\n                -1,\n                1,\n                1,\n                0\n            ],\n            [\n                -1,\n                1,\n                -1,\n                0\n            ],\n            [\n                -1,\n                -1,\n                1,\n                0\n            ],\n            [\n                -1,\n                -1,\n                -1,\n                0\n            ]\n        ];\n        this.p = [];\n        for(let i = 0; i < 256; i++)this.p[i] = Math.floor(r.random() * 256);\n        // To remove the need for index wrapping, double the permutation table length\n        this.perm = [];\n        for(let i = 0; i < 512; i++)this.perm[i] = this.p[i & 255];\n        // A lookup table to traverse the simplex around a given point in 4D.\n        // Details can be found where this table is used, in the 4D noise method.\n        this.simplex = [\n            [\n                0,\n                1,\n                2,\n                3\n            ],\n            [\n                0,\n                1,\n                3,\n                2\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                2,\n                3,\n                1\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                1,\n                2,\n                3,\n                0\n            ],\n            [\n                0,\n                2,\n                1,\n                3\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                3,\n                1,\n                2\n            ],\n            [\n                0,\n                3,\n                2,\n                1\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                1,\n                3,\n                2,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                1,\n                2,\n                0,\n                3\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                1,\n                3,\n                0,\n                2\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                2,\n                3,\n                0,\n                1\n            ],\n            [\n                2,\n                3,\n                1,\n                0\n            ],\n            [\n                1,\n                0,\n                2,\n                3\n            ],\n            [\n                1,\n                0,\n                3,\n                2\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                2,\n                0,\n                3,\n                1\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                2,\n                1,\n                3,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                2,\n                0,\n                1,\n                3\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                3,\n                0,\n                1,\n                2\n            ],\n            [\n                3,\n                0,\n                2,\n                1\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                3,\n                1,\n                2,\n                0\n            ],\n            [\n                2,\n                1,\n                0,\n                3\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                3,\n                1,\n                0,\n                2\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                3,\n                2,\n                0,\n                1\n            ],\n            [\n                3,\n                2,\n                1,\n                0\n            ]\n        ];\n    }\n    dot(g, x, y) {\n        return g[0] * x + g[1] * y;\n    }\n    dot3(g, x, y, z) {\n        return g[0] * x + g[1] * y + g[2] * z;\n    }\n    dot4(g, x, y, z, w) {\n        return g[0] * x + g[1] * y + g[2] * z + g[3] * w;\n    }\n    noise(xin, yin) {\n        let n0; // Noise contributions from the three corners\n        let n1;\n        let n2;\n        // Skew the input space to determine which simplex cell we're in\n        const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);\n        const s = (xin + yin) * F2; // Hairy factor for 2D\n        const i = Math.floor(xin + s);\n        const j = Math.floor(yin + s);\n        const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;\n        const t = (i + j) * G2;\n        const X0 = i - t; // Unskew the cell origin back to (x,y) space\n        const Y0 = j - t;\n        const x0 = xin - X0; // The x,y distances from the cell origin\n        const y0 = yin - Y0;\n        // For the 2D case, the simplex shape is an equilateral triangle.\n        // Determine which simplex we are in.\n        let i1; // Offsets for second (middle) corner of simplex in (i,j) coords\n        let j1;\n        if (x0 > y0) {\n            i1 = 1;\n            j1 = 0;\n        // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n        } else {\n            i1 = 0;\n            j1 = 1;\n        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n        // c = (3-sqrt(3))/6\n        const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n        const y1 = y0 - j1 + G2;\n        const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n        const y2 = y0 - 1.0 + 2.0 * G2;\n        // Work out the hashed gradient indices of the three simplex corners\n        const ii = i & 255;\n        const jj = j & 255;\n        const gi0 = this.perm[ii + this.perm[jj]] % 12;\n        const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;\n        const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;\n        // Calculate the contribution from the three corners\n        let t0 = 0.5 - x0 * x0 - y0 * y0;\n        if (t0 < 0) n0 = 0.0;\n        else {\n            t0 *= t0;\n            n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n        }\n        let t1 = 0.5 - x1 * x1 - y1 * y1;\n        if (t1 < 0) n1 = 0.0;\n        else {\n            t1 *= t1;\n            n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);\n        }\n        let t2 = 0.5 - x2 * x2 - y2 * y2;\n        if (t2 < 0) n2 = 0.0;\n        else {\n            t2 *= t2;\n            n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);\n        }\n        // Add contributions from each corner to get the final noise value.\n        // The result is scaled to return values in the interval [-1,1].\n        return 70.0 * (n0 + n1 + n2);\n    }\n    // 3D simplex noise\n    noise3d(xin, yin, zin) {\n        let n0; // Noise contributions from the four corners\n        let n1;\n        let n2;\n        let n3;\n        // Skew the input space to determine which simplex cell we're in\n        const F3 = 1.0 / 3.0;\n        const s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D\n        const i = Math.floor(xin + s);\n        const j = Math.floor(yin + s);\n        const k = Math.floor(zin + s);\n        const G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too\n        const t = (i + j + k) * G3;\n        const X0 = i - t; // Unskew the cell origin back to (x,y,z) space\n        const Y0 = j - t;\n        const Z0 = k - t;\n        const x0 = xin - X0; // The x,y,z distances from the cell origin\n        const y0 = yin - Y0;\n        const z0 = zin - Z0;\n        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n        // Determine which simplex we are in.\n        let i1; // Offsets for second corner of simplex in (i,j,k) coords\n        let j1;\n        let k1;\n        let i2; // Offsets for third corner of simplex in (i,j,k) coords\n        let j2;\n        let k2;\n        if (x0 >= y0) {\n            if (y0 >= z0) {\n                i1 = 1;\n                j1 = 0;\n                k1 = 0;\n                i2 = 1;\n                j2 = 1;\n                k2 = 0;\n            // X Y Z order\n            } else if (x0 >= z0) {\n                i1 = 1;\n                j1 = 0;\n                k1 = 0;\n                i2 = 1;\n                j2 = 0;\n                k2 = 1;\n            // X Z Y order\n            } else {\n                i1 = 0;\n                j1 = 0;\n                k1 = 1;\n                i2 = 1;\n                j2 = 0;\n                k2 = 1;\n            } // Z X Y order\n        } else {\n            if (y0 < z0) {\n                i1 = 0;\n                j1 = 0;\n                k1 = 1;\n                i2 = 0;\n                j2 = 1;\n                k2 = 1;\n            // Z Y X order\n            } else if (x0 < z0) {\n                i1 = 0;\n                j1 = 1;\n                k1 = 0;\n                i2 = 0;\n                j2 = 1;\n                k2 = 1;\n            // Y Z X order\n            } else {\n                i1 = 0;\n                j1 = 1;\n                k1 = 0;\n                i2 = 1;\n                j2 = 1;\n                k2 = 0;\n            } // Y X Z order\n        }\n        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n        // c = 1/6.\n        const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n        const y1 = y0 - j1 + G3;\n        const z1 = z0 - k1 + G3;\n        const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\n        const y2 = y0 - j2 + 2.0 * G3;\n        const z2 = z0 - k2 + 2.0 * G3;\n        const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\n        const y3 = y0 - 1.0 + 3.0 * G3;\n        const z3 = z0 - 1.0 + 3.0 * G3;\n        // Work out the hashed gradient indices of the four simplex corners\n        const ii = i & 255;\n        const jj = j & 255;\n        const kk = k & 255;\n        const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;\n        const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;\n        const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;\n        const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;\n        // Calculate the contribution from the four corners\n        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n        if (t0 < 0) n0 = 0.0;\n        else {\n            t0 *= t0;\n            n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);\n        }\n        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n        if (t1 < 0) n1 = 0.0;\n        else {\n            t1 *= t1;\n            n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);\n        }\n        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n        if (t2 < 0) n2 = 0.0;\n        else {\n            t2 *= t2;\n            n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);\n        }\n        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n        if (t3 < 0) n3 = 0.0;\n        else {\n            t3 *= t3;\n            n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);\n        }\n        // Add contributions from each corner to get the final noise value.\n        // The result is scaled to stay just inside [-1,1]\n        return 32.0 * (n0 + n1 + n2 + n3);\n    }\n    // 4D simplex noise\n    noise4d(x, y, z, w) {\n        // For faster and easier lookups\n        const grad4 = this.grad4;\n        const simplex = this.simplex;\n        const perm = this.perm;\n        // The skewing and unskewing factors are hairy again for the 4D case\n        const F4 = (Math.sqrt(5.0) - 1.0) / 4.0;\n        const G4 = (5.0 - Math.sqrt(5.0)) / 20.0;\n        let n0; // Noise contributions from the five corners\n        let n1;\n        let n2;\n        let n3;\n        let n4;\n        // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n        const s = (x + y + z + w) * F4; // Factor for 4D skewing\n        const i = Math.floor(x + s);\n        const j = Math.floor(y + s);\n        const k = Math.floor(z + s);\n        const l = Math.floor(w + s);\n        const t = (i + j + k + l) * G4; // Factor for 4D unskewing\n        const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n        const Y0 = j - t;\n        const Z0 = k - t;\n        const W0 = l - t;\n        const x0 = x - X0; // The x,y,z,w distances from the cell origin\n        const y0 = y - Y0;\n        const z0 = z - Z0;\n        const w0 = w - W0;\n        // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n        // To find out which of the 24 possible simplices we're in, we need to\n        // determine the magnitude ordering of x0, y0, z0 and w0.\n        // The method below is a good way of finding the ordering of x,y,z,w and\n        // then find the correct traversal order for the simplex we’re in.\n        // First, six pair-wise comparisons are performed between each possible pair\n        // of the four coordinates, and the results are used to add up binary bits\n        // for an integer index.\n        const c1 = x0 > y0 ? 32 : 0;\n        const c2 = x0 > z0 ? 16 : 0;\n        const c3 = y0 > z0 ? 8 : 0;\n        const c4 = x0 > w0 ? 4 : 0;\n        const c5 = y0 > w0 ? 2 : 0;\n        const c6 = z0 > w0 ? 1 : 0;\n        const c = c1 + c2 + c3 + c4 + c5 + c6;\n        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n        // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n        // impossible. Only the 24 indices which have non-zero entries make any sense.\n        // We use a thresholding to set the coordinates in turn from the largest magnitude.\n        // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n        const i1 = simplex[c][0] >= 3 ? 1 : 0;\n        const j1 = simplex[c][1] >= 3 ? 1 : 0;\n        const k1 = simplex[c][2] >= 3 ? 1 : 0;\n        const l1 = simplex[c][3] >= 3 ? 1 : 0;\n        // The number 2 in the \"simplex\" array is at the second largest coordinate.\n        const i2 = simplex[c][0] >= 2 ? 1 : 0;\n        const j2 = simplex[c][1] >= 2 ? 1 : 0;\n        const k2 = simplex[c][2] >= 2 ? 1 : 0;\n        const l2 = simplex[c][3] >= 2 ? 1 : 0;\n        // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n        const i3 = simplex[c][0] >= 1 ? 1 : 0;\n        const j3 = simplex[c][1] >= 1 ? 1 : 0;\n        const k3 = simplex[c][2] >= 1 ? 1 : 0;\n        const l3 = simplex[c][3] >= 1 ? 1 : 0;\n        // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n        const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n        const y1 = y0 - j1 + G4;\n        const z1 = z0 - k1 + G4;\n        const w1 = w0 - l1 + G4;\n        const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\n        const y2 = y0 - j2 + 2.0 * G4;\n        const z2 = z0 - k2 + 2.0 * G4;\n        const w2 = w0 - l2 + 2.0 * G4;\n        const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\n        const y3 = y0 - j3 + 3.0 * G4;\n        const z3 = z0 - k3 + 3.0 * G4;\n        const w3 = w0 - l3 + 3.0 * G4;\n        const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\n        const y4 = y0 - 1.0 + 4.0 * G4;\n        const z4 = z0 - 1.0 + 4.0 * G4;\n        const w4 = w0 - 1.0 + 4.0 * G4;\n        // Work out the hashed gradient indices of the five simplex corners\n        const ii = i & 255;\n        const jj = j & 255;\n        const kk = k & 255;\n        const ll = l & 255;\n        const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;\n        const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;\n        const gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;\n        const gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;\n        const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;\n        // Calculate the contribution from the five corners\n        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\n        if (t0 < 0) n0 = 0.0;\n        else {\n            t0 *= t0;\n            n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);\n        }\n        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\n        if (t1 < 0) n1 = 0.0;\n        else {\n            t1 *= t1;\n            n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);\n        }\n        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\n        if (t2 < 0) n2 = 0.0;\n        else {\n            t2 *= t2;\n            n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);\n        }\n        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\n        if (t3 < 0) n3 = 0.0;\n        else {\n            t3 *= t3;\n            n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);\n        }\n        let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\n        if (t4 < 0) n4 = 0.0;\n        else {\n            t4 *= t4;\n            n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);\n        }\n        // Sum up and scale the result to cover the range [-1,1]\n        return 27.0 * (n0 + n1 + n2 + n3 + n4);\n    }\n}\n\n\nonmessage = function(event) {\n    const { chunkPosition: chunkPosition, chunkSize: chunkSize, instanceCount: instanceCount } = event.data;\n    //console.log(event.data)\n    const simplex = new (0, $2450539c160c7a52$export$7cef8d54b4fb09be)();\n    const offsets = new Float32Array(instanceCount * 3);\n    const uvs = new Float32Array(instanceCount * 2);\n    const rotationMatrices = new Float32Array(instanceCount * 9);\n    const scales = new Float32Array(instanceCount);\n    const normalizedHeight = new Float32Array(instanceCount);\n    // Generate instance data\n    for(let i = 0; i < instanceCount; i++){\n        offsets[i * 3] = chunkPosition.x + Math.random() * chunkSize;\n        offsets[i * 3 + 2] = chunkPosition.y + Math.random() * chunkSize;\n        //offsets[i * 3 + 1] = getHeight(offsets[i * 3], offsets[i * 3 + 2]);\n        offsets[i * 3 + 1] = 0;\n        //set UV's\n        uvs[i] = [\n            convertRange(offsets[i * 3], chunkPosition.x, chunkPosition.x + chunkSize, 0 + chunkSize, chunkPosition.x / chunkSize)\n        ];\n        uvs[i + 2] = [\n            convertRange(offsets[i * 3 + 2], chunkPosition.y, chunkPosition.y + chunkSize, 0 + chunkSize, chunkPosition.y / chunkSize)\n        ];\n        const angle = Math.random() * Math.PI * 2;\n        const cosAngle = Math.cos(angle);\n        const sinAngle = Math.sin(angle);\n        const index = i * 9;\n        rotationMatrices[index + 0] = cosAngle;\n        rotationMatrices[index + 1] = 0;\n        rotationMatrices[index + 2] = -sinAngle;\n        rotationMatrices[index + 3] = 0;\n        rotationMatrices[index + 4] = 1;\n        rotationMatrices[index + 5] = 0;\n        rotationMatrices[index + 6] = sinAngle;\n        rotationMatrices[index + 7] = 0;\n        rotationMatrices[index + 8] = cosAngle;\n        scales[i] = Math.random() * 2.0 + 3.5;\n        normalizedHeight[i] = (scales[i] - 2.0) / 3.5;\n    }\n    function convertRange(val, oldMin, oldMax, newMin, newMax) {\n        return (val - oldMin) * (newMax - newMin) / (oldMax - oldMin) + newMin;\n    }\n    postMessage({\n        offsets: offsets,\n        uvs: uvs,\n        rotationMatrices: rotationMatrices,\n        scales: scales,\n        normalizedHeight: normalizedHeight\n    });\n};\n\n})();\n//# sourceMappingURL=worker.f94b5f94.js.map\n","// worker.js\r\nimport { SimplexNoise } from \"three/examples/jsm/math/SimplexNoise\";\r\n\r\n\r\nonmessage = function (event) {\r\n    const { chunkPosition, chunkSize, instanceCount } = event.data;\r\n    //console.log(event.data)\r\n    const simplex = new SimplexNoise();\r\n\r\n\r\n    const offsets = new Float32Array(instanceCount * 3);\r\n    const uvs = new Float32Array(instanceCount * 2);\r\n    const rotationMatrices = new Float32Array(instanceCount * 9);\r\n    const scales = new Float32Array(instanceCount);\r\n    const normalizedHeight = new Float32Array(instanceCount);\r\n\r\n\r\n    // Generate instance data\r\n    for (let i = 0; i < instanceCount; i++) {\r\n        offsets[i * 3] = chunkPosition.x + (Math.random() * chunkSize);\r\n        offsets[i * 3 + 2] = chunkPosition.y + (Math.random() * chunkSize);\r\n        //offsets[i * 3 + 1] = getHeight(offsets[i * 3], offsets[i * 3 + 2]);\r\n        offsets[i * 3 + 1] = 0;\r\n\r\n        //set UV's\r\n        uvs[i] = [convertRange(offsets[i * 3], chunkPosition.x, (chunkPosition.x + chunkSize), (0 + chunkSize), (chunkPosition.x / chunkSize))];\r\n        uvs[i + 2] = [convertRange(offsets[i * 3 + 2], chunkPosition.y, (chunkPosition.y + chunkSize), (0 + chunkSize), (chunkPosition.y / chunkSize))];\r\n\r\n        const angle = Math.random() * Math.PI * 2;\r\n        const cosAngle = Math.cos(angle);\r\n        const sinAngle = Math.sin(angle);\r\n\r\n        const index = i * 9;\r\n        rotationMatrices[index + 0] = cosAngle;\r\n        rotationMatrices[index + 1] = 0;\r\n        rotationMatrices[index + 2] = -sinAngle;\r\n\r\n        rotationMatrices[index + 3] = 0;\r\n        rotationMatrices[index + 4] = 1;\r\n        rotationMatrices[index + 5] = 0;\r\n\r\n        rotationMatrices[index + 6] = sinAngle;\r\n        rotationMatrices[index + 7] = 0;\r\n        rotationMatrices[index + 8] = cosAngle;\r\n\r\n        scales[i] = Math.random() * 2.0 + 3.5;\r\n        normalizedHeight[i] = (scales[i] - 2.0) / (5.50 - 2.0);\r\n    }\r\n\r\n    function convertRange(val, oldMin, oldMax, newMin, newMax) {\r\n        return (((val - oldMin) * (newMax - newMin)) / (oldMax - oldMin)) + newMin;\r\n    }\r\n\r\n\r\n    postMessage({\r\n        offsets,\r\n        uvs,\r\n        rotationMatrices,\r\n        scales,\r\n        normalizedHeight\r\n    });\r\n};","// Ported from Stefan Gustavson's java implementation\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n// Read Stefan's excellent paper for details on how this code works.\n//\n// Sean McCullough banksean@gmail.com\n//\n// Added 4D noise\n\n/**\n * You can pass in a random number generator object if you like.\n * It is assumed to have a random() method.\n */\nclass SimplexNoise {\n\n\tconstructor( r = Math ) {\n\n\t\tthis.grad3 = [[ 1, 1, 0 ], [ - 1, 1, 0 ], [ 1, - 1, 0 ], [ - 1, - 1, 0 ],\n\t\t\t[ 1, 0, 1 ], [ - 1, 0, 1 ], [ 1, 0, - 1 ], [ - 1, 0, - 1 ],\n\t\t\t[ 0, 1, 1 ], [ 0, - 1, 1 ], [ 0, 1, - 1 ], [ 0, - 1, - 1 ]];\n\n\t\tthis.grad4 = [[ 0, 1, 1, 1 ], [ 0, 1, 1, - 1 ], [ 0, 1, - 1, 1 ], [ 0, 1, - 1, - 1 ],\n\t\t\t[ 0, - 1, 1, 1 ], [ 0, - 1, 1, - 1 ], [ 0, - 1, - 1, 1 ], [ 0, - 1, - 1, - 1 ],\n\t\t\t[ 1, 0, 1, 1 ], [ 1, 0, 1, - 1 ], [ 1, 0, - 1, 1 ], [ 1, 0, - 1, - 1 ],\n\t\t\t[ - 1, 0, 1, 1 ], [ - 1, 0, 1, - 1 ], [ - 1, 0, - 1, 1 ], [ - 1, 0, - 1, - 1 ],\n\t\t\t[ 1, 1, 0, 1 ], [ 1, 1, 0, - 1 ], [ 1, - 1, 0, 1 ], [ 1, - 1, 0, - 1 ],\n\t\t\t[ - 1, 1, 0, 1 ], [ - 1, 1, 0, - 1 ], [ - 1, - 1, 0, 1 ], [ - 1, - 1, 0, - 1 ],\n\t\t\t[ 1, 1, 1, 0 ], [ 1, 1, - 1, 0 ], [ 1, - 1, 1, 0 ], [ 1, - 1, - 1, 0 ],\n\t\t\t[ - 1, 1, 1, 0 ], [ - 1, 1, - 1, 0 ], [ - 1, - 1, 1, 0 ], [ - 1, - 1, - 1, 0 ]];\n\n\t\tthis.p = [];\n\n\t\tfor ( let i = 0; i < 256; i ++ ) {\n\n\t\t\tthis.p[ i ] = Math.floor( r.random() * 256 );\n\n\t\t}\n\n\t\t// To remove the need for index wrapping, double the permutation table length\n\t\tthis.perm = [];\n\n\t\tfor ( let i = 0; i < 512; i ++ ) {\n\n\t\t\tthis.perm[ i ] = this.p[ i & 255 ];\n\n\t\t}\n\n\t\t// A lookup table to traverse the simplex around a given point in 4D.\n\t\t// Details can be found where this table is used, in the 4D noise method.\n\t\tthis.simplex = [\n\t\t\t[ 0, 1, 2, 3 ], [ 0, 1, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 2, 3, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 2, 3, 0 ],\n\t\t\t[ 0, 2, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 3, 1, 2 ], [ 0, 3, 2, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 3, 2, 0 ],\n\t\t\t[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],\n\t\t\t[ 1, 2, 0, 3 ], [ 0, 0, 0, 0 ], [ 1, 3, 0, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 3, 0, 1 ], [ 2, 3, 1, 0 ],\n\t\t\t[ 1, 0, 2, 3 ], [ 1, 0, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 0, 3, 1 ], [ 0, 0, 0, 0 ], [ 2, 1, 3, 0 ],\n\t\t\t[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],\n\t\t\t[ 2, 0, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 0, 1, 2 ], [ 3, 0, 2, 1 ], [ 0, 0, 0, 0 ], [ 3, 1, 2, 0 ],\n\t\t\t[ 2, 1, 0, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 1, 0, 2 ], [ 0, 0, 0, 0 ], [ 3, 2, 0, 1 ], [ 3, 2, 1, 0 ]];\n\n\t}\n\n\tdot( g, x, y ) {\n\n\t\treturn g[ 0 ] * x + g[ 1 ] * y;\n\n\t}\n\n\tdot3( g, x, y, z ) {\n\n\t\treturn g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z;\n\n\t}\n\n\tdot4( g, x, y, z, w ) {\n\n\t\treturn g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z + g[ 3 ] * w;\n\n\t}\n\n\tnoise( xin, yin ) {\n\n\t\tlet n0; // Noise contributions from the three corners\n\t\tlet n1;\n\t\tlet n2;\n\t\t// Skew the input space to determine which simplex cell we're in\n\t\tconst F2 = 0.5 * ( Math.sqrt( 3.0 ) - 1.0 );\n\t\tconst s = ( xin + yin ) * F2; // Hairy factor for 2D\n\t\tconst i = Math.floor( xin + s );\n\t\tconst j = Math.floor( yin + s );\n\t\tconst G2 = ( 3.0 - Math.sqrt( 3.0 ) ) / 6.0;\n\t\tconst t = ( i + j ) * G2;\n\t\tconst X0 = i - t; // Unskew the cell origin back to (x,y) space\n\t\tconst Y0 = j - t;\n\t\tconst x0 = xin - X0; // The x,y distances from the cell origin\n\t\tconst y0 = yin - Y0;\n\n\t\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t\t// Determine which simplex we are in.\n\t\tlet i1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\n\t\tlet j1;\n\t\tif ( x0 > y0 ) {\n\n\t\t\ti1 = 1; j1 = 0;\n\n\t\t\t// lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\n\t\t}\telse {\n\n\t\t\ti1 = 0; j1 = 1;\n\n\t\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\n\t\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t\t// c = (3-sqrt(3))/6\n\t\tconst x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\t\tconst y1 = y0 - j1 + G2;\n\t\tconst x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\t\tconst y2 = y0 - 1.0 + 2.0 * G2;\n\t\t// Work out the hashed gradient indices of the three simplex corners\n\t\tconst ii = i & 255;\n\t\tconst jj = j & 255;\n\t\tconst gi0 = this.perm[ ii + this.perm[ jj ] ] % 12;\n\t\tconst gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 ] ] % 12;\n\t\tconst gi2 = this.perm[ ii + 1 + this.perm[ jj + 1 ] ] % 12;\n\t\t// Calculate the contribution from the three corners\n\t\tlet t0 = 0.5 - x0 * x0 - y0 * y0;\n\t\tif ( t0 < 0 ) n0 = 0.0;\n\t\telse {\n\n\t\t\tt0 *= t0;\n\t\t\tn0 = t0 * t0 * this.dot( this.grad3[ gi0 ], x0, y0 ); // (x,y) of grad3 used for 2D gradient\n\n\t\t}\n\n\t\tlet t1 = 0.5 - x1 * x1 - y1 * y1;\n\t\tif ( t1 < 0 ) n1 = 0.0;\n\t\telse {\n\n\t\t\tt1 *= t1;\n\t\t\tn1 = t1 * t1 * this.dot( this.grad3[ gi1 ], x1, y1 );\n\n\t\t}\n\n\t\tlet t2 = 0.5 - x2 * x2 - y2 * y2;\n\t\tif ( t2 < 0 ) n2 = 0.0;\n\t\telse {\n\n\t\t\tt2 *= t2;\n\t\t\tn2 = t2 * t2 * this.dot( this.grad3[ gi2 ], x2, y2 );\n\n\t\t}\n\n\t\t// Add contributions from each corner to get the final noise value.\n\t\t// The result is scaled to return values in the interval [-1,1].\n\t\treturn 70.0 * ( n0 + n1 + n2 );\n\n\t}\n\n\t// 3D simplex noise\n\tnoise3d( xin, yin, zin ) {\n\n\t\tlet n0; // Noise contributions from the four corners\n\t\tlet n1;\n\t\tlet n2;\n\t\tlet n3;\n\t\t// Skew the input space to determine which simplex cell we're in\n\t\tconst F3 = 1.0 / 3.0;\n\t\tconst s = ( xin + yin + zin ) * F3; // Very nice and simple skew factor for 3D\n\t\tconst i = Math.floor( xin + s );\n\t\tconst j = Math.floor( yin + s );\n\t\tconst k = Math.floor( zin + s );\n\t\tconst G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too\n\t\tconst t = ( i + j + k ) * G3;\n\t\tconst X0 = i - t; // Unskew the cell origin back to (x,y,z) space\n\t\tconst Y0 = j - t;\n\t\tconst Z0 = k - t;\n\t\tconst x0 = xin - X0; // The x,y,z distances from the cell origin\n\t\tconst y0 = yin - Y0;\n\t\tconst z0 = zin - Z0;\n\n\t\t// For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t\t// Determine which simplex we are in.\n\t\tlet i1; // Offsets for second corner of simplex in (i,j,k) coords\n\n\t\tlet j1;\n\t\tlet k1;\n\t\tlet i2; // Offsets for third corner of simplex in (i,j,k) coords\n\t\tlet j2;\n\t\tlet k2;\n\t\tif ( x0 >= y0 ) {\n\n\t\t\tif ( y0 >= z0 ) {\n\n\t\t\t\ti1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;\n\n\t\t\t\t// X Y Z order\n\n\t\t\t} else if ( x0 >= z0 ) {\n\n\t\t\t\ti1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;\n\n\t\t\t\t// X Z Y order\n\n\t\t\t} else {\n\n\t\t\t\ti1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;\n\n\t\t\t} // Z X Y order\n\n\t\t} else { // x0<y0\n\n\t\t\tif ( y0 < z0 ) {\n\n\t\t\t\ti1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;\n\n\t\t\t\t// Z Y X order\n\n\t\t\t} else if ( x0 < z0 ) {\n\n\t\t\t\ti1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;\n\n\t\t\t\t// Y Z X order\n\n\t\t\t} else {\n\n\t\t\t\ti1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;\n\n\t\t\t} // Y X Z order\n\n\t\t}\n\n\t\t// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n\t\t// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n\t\t// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n\t\t// c = 1/6.\n\t\tconst x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n\t\tconst y1 = y0 - j1 + G3;\n\t\tconst z1 = z0 - k1 + G3;\n\t\tconst x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\n\t\tconst y2 = y0 - j2 + 2.0 * G3;\n\t\tconst z2 = z0 - k2 + 2.0 * G3;\n\t\tconst x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\n\t\tconst y3 = y0 - 1.0 + 3.0 * G3;\n\t\tconst z3 = z0 - 1.0 + 3.0 * G3;\n\t\t// Work out the hashed gradient indices of the four simplex corners\n\t\tconst ii = i & 255;\n\t\tconst jj = j & 255;\n\t\tconst kk = k & 255;\n\t\tconst gi0 = this.perm[ ii + this.perm[ jj + this.perm[ kk ] ] ] % 12;\n\t\tconst gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 + this.perm[ kk + k1 ] ] ] % 12;\n\t\tconst gi2 = this.perm[ ii + i2 + this.perm[ jj + j2 + this.perm[ kk + k2 ] ] ] % 12;\n\t\tconst gi3 = this.perm[ ii + 1 + this.perm[ jj + 1 + this.perm[ kk + 1 ] ] ] % 12;\n\t\t// Calculate the contribution from the four corners\n\t\tlet t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n\t\tif ( t0 < 0 ) n0 = 0.0;\n\t\telse {\n\n\t\t\tt0 *= t0;\n\t\t\tn0 = t0 * t0 * this.dot3( this.grad3[ gi0 ], x0, y0, z0 );\n\n\t\t}\n\n\t\tlet t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n\t\tif ( t1 < 0 ) n1 = 0.0;\n\t\telse {\n\n\t\t\tt1 *= t1;\n\t\t\tn1 = t1 * t1 * this.dot3( this.grad3[ gi1 ], x1, y1, z1 );\n\n\t\t}\n\n\t\tlet t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n\t\tif ( t2 < 0 ) n2 = 0.0;\n\t\telse {\n\n\t\t\tt2 *= t2;\n\t\t\tn2 = t2 * t2 * this.dot3( this.grad3[ gi2 ], x2, y2, z2 );\n\n\t\t}\n\n\t\tlet t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n\t\tif ( t3 < 0 ) n3 = 0.0;\n\t\telse {\n\n\t\t\tt3 *= t3;\n\t\t\tn3 = t3 * t3 * this.dot3( this.grad3[ gi3 ], x3, y3, z3 );\n\n\t\t}\n\n\t\t// Add contributions from each corner to get the final noise value.\n\t\t// The result is scaled to stay just inside [-1,1]\n\t\treturn 32.0 * ( n0 + n1 + n2 + n3 );\n\n\t}\n\n\t// 4D simplex noise\n\tnoise4d( x, y, z, w ) {\n\n\t\t// For faster and easier lookups\n\t\tconst grad4 = this.grad4;\n\t\tconst simplex = this.simplex;\n\t\tconst perm = this.perm;\n\n\t\t// The skewing and unskewing factors are hairy again for the 4D case\n\t\tconst F4 = ( Math.sqrt( 5.0 ) - 1.0 ) / 4.0;\n\t\tconst G4 = ( 5.0 - Math.sqrt( 5.0 ) ) / 20.0;\n\t\tlet n0; // Noise contributions from the five corners\n\t\tlet n1;\n\t\tlet n2;\n\t\tlet n3;\n\t\tlet n4;\n\t\t// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\t\tconst s = ( x + y + z + w ) * F4; // Factor for 4D skewing\n\t\tconst i = Math.floor( x + s );\n\t\tconst j = Math.floor( y + s );\n\t\tconst k = Math.floor( z + s );\n\t\tconst l = Math.floor( w + s );\n\t\tconst t = ( i + j + k + l ) * G4; // Factor for 4D unskewing\n\t\tconst X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n\t\tconst Y0 = j - t;\n\t\tconst Z0 = k - t;\n\t\tconst W0 = l - t;\n\t\tconst x0 = x - X0; // The x,y,z,w distances from the cell origin\n\t\tconst y0 = y - Y0;\n\t\tconst z0 = z - Z0;\n\t\tconst w0 = w - W0;\n\n\t\t// For the 4D case, the simplex is a 4D shape I won't even try to describe.\n\t\t// To find out which of the 24 possible simplices we're in, we need to\n\t\t// determine the magnitude ordering of x0, y0, z0 and w0.\n\t\t// The method below is a good way of finding the ordering of x,y,z,w and\n\t\t// then find the correct traversal order for the simplex we’re in.\n\t\t// First, six pair-wise comparisons are performed between each possible pair\n\t\t// of the four coordinates, and the results are used to add up binary bits\n\t\t// for an integer index.\n\t\tconst c1 = ( x0 > y0 ) ? 32 : 0;\n\t\tconst c2 = ( x0 > z0 ) ? 16 : 0;\n\t\tconst c3 = ( y0 > z0 ) ? 8 : 0;\n\t\tconst c4 = ( x0 > w0 ) ? 4 : 0;\n\t\tconst c5 = ( y0 > w0 ) ? 2 : 0;\n\t\tconst c6 = ( z0 > w0 ) ? 1 : 0;\n\t\tconst c = c1 + c2 + c3 + c4 + c5 + c6;\n\n\t\t// simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n\t\t// Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n\t\t// impossible. Only the 24 indices which have non-zero entries make any sense.\n\t\t// We use a thresholding to set the coordinates in turn from the largest magnitude.\n\t\t// The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n\t\tconst i1 = simplex[ c ][ 0 ] >= 3 ? 1 : 0;\n\t\tconst j1 = simplex[ c ][ 1 ] >= 3 ? 1 : 0;\n\t\tconst k1 = simplex[ c ][ 2 ] >= 3 ? 1 : 0;\n\t\tconst l1 = simplex[ c ][ 3 ] >= 3 ? 1 : 0;\n\t\t// The number 2 in the \"simplex\" array is at the second largest coordinate.\n\t\tconst i2 = simplex[ c ][ 0 ] >= 2 ? 1 : 0;\n\t\tconst j2 = simplex[ c ][ 1 ] >= 2 ? 1 : 0;\n\t\tconst k2 = simplex[ c ][ 2 ] >= 2 ? 1 : 0;\n\t\tconst l2 = simplex[ c ][ 3 ] >= 2 ? 1 : 0;\n\t\t// The number 1 in the \"simplex\" array is at the second smallest coordinate.\n\t\tconst i3 = simplex[ c ][ 0 ] >= 1 ? 1 : 0;\n\t\tconst j3 = simplex[ c ][ 1 ] >= 1 ? 1 : 0;\n\t\tconst k3 = simplex[ c ][ 2 ] >= 1 ? 1 : 0;\n\t\tconst l3 = simplex[ c ][ 3 ] >= 1 ? 1 : 0;\n\t\t// The fifth corner has all coordinate offsets = 1, so no need to look that up.\n\t\tconst x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n\t\tconst y1 = y0 - j1 + G4;\n\t\tconst z1 = z0 - k1 + G4;\n\t\tconst w1 = w0 - l1 + G4;\n\t\tconst x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\n\t\tconst y2 = y0 - j2 + 2.0 * G4;\n\t\tconst z2 = z0 - k2 + 2.0 * G4;\n\t\tconst w2 = w0 - l2 + 2.0 * G4;\n\t\tconst x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\n\t\tconst y3 = y0 - j3 + 3.0 * G4;\n\t\tconst z3 = z0 - k3 + 3.0 * G4;\n\t\tconst w3 = w0 - l3 + 3.0 * G4;\n\t\tconst x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\n\t\tconst y4 = y0 - 1.0 + 4.0 * G4;\n\t\tconst z4 = z0 - 1.0 + 4.0 * G4;\n\t\tconst w4 = w0 - 1.0 + 4.0 * G4;\n\t\t// Work out the hashed gradient indices of the five simplex corners\n\t\tconst ii = i & 255;\n\t\tconst jj = j & 255;\n\t\tconst kk = k & 255;\n\t\tconst ll = l & 255;\n\t\tconst gi0 = perm[ ii + perm[ jj + perm[ kk + perm[ ll ] ] ] ] % 32;\n\t\tconst gi1 = perm[ ii + i1 + perm[ jj + j1 + perm[ kk + k1 + perm[ ll + l1 ] ] ] ] % 32;\n\t\tconst gi2 = perm[ ii + i2 + perm[ jj + j2 + perm[ kk + k2 + perm[ ll + l2 ] ] ] ] % 32;\n\t\tconst gi3 = perm[ ii + i3 + perm[ jj + j3 + perm[ kk + k3 + perm[ ll + l3 ] ] ] ] % 32;\n\t\tconst gi4 = perm[ ii + 1 + perm[ jj + 1 + perm[ kk + 1 + perm[ ll + 1 ] ] ] ] % 32;\n\t\t// Calculate the contribution from the five corners\n\t\tlet t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\n\t\tif ( t0 < 0 ) n0 = 0.0;\n\t\telse {\n\n\t\t\tt0 *= t0;\n\t\t\tn0 = t0 * t0 * this.dot4( grad4[ gi0 ], x0, y0, z0, w0 );\n\n\t\t}\n\n\t\tlet t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\n\t\tif ( t1 < 0 ) n1 = 0.0;\n\t\telse {\n\n\t\t\tt1 *= t1;\n\t\t\tn1 = t1 * t1 * this.dot4( grad4[ gi1 ], x1, y1, z1, w1 );\n\n\t\t}\n\n\t\tlet t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\n\t\tif ( t2 < 0 ) n2 = 0.0;\n\t\telse {\n\n\t\t\tt2 *= t2;\n\t\t\tn2 = t2 * t2 * this.dot4( grad4[ gi2 ], x2, y2, z2, w2 );\n\n\t\t}\n\n\t\tlet t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\n\t\tif ( t3 < 0 ) n3 = 0.0;\n\t\telse {\n\n\t\t\tt3 *= t3;\n\t\t\tn3 = t3 * t3 * this.dot4( grad4[ gi3 ], x3, y3, z3, w3 );\n\n\t\t}\n\n\t\tlet t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\n\t\tif ( t4 < 0 ) n4 = 0.0;\n\t\telse {\n\n\t\t\tt4 *= t4;\n\t\t\tn4 = t4 * t4 * this.dot4( grad4[ gi4 ], x4, y4, z4, w4 );\n\n\t\t}\n\n\t\t// Sum up and scale the result to cover the range [-1,1]\n\t\treturn 27.0 * ( n0 + n1 + n2 + n3 + n4 );\n\n\t}\n\n}\n\nexport { SimplexNoise };\n"],"names":["$2450539c160c7a52$export$7cef8d54b4fb09be","constructor","r","Math","grad3","grad4","p","i","floor","random","perm","simplex","dot","g","x","y","dot3","z","dot4","w","noise","xin","yin","n0","n1","n2","i1","j1","s","sqrt","j","G2","t","x0","y0","x1","y1","x2","y2","ii","jj","gi0","gi1","gi2","t0","t1","t2","noise3d","zin","n3","k1","i2","j2","k2","k","z0","z1","z2","x3","y3","z3","kk","gi3","t3","noise4d","n4","G4","l","w0","c","c1","l1","l2","i3","j3","k3","l3","w1","w2","w3","x4","y4","z4","w4","ll","gi4","t4","onmessage","event","chunkPosition","chunkSize","instanceCount","data","offsets","Float32Array","uvs","rotationMatrices","scales","normalizedHeight","val","oldMin","oldMax","newMin","newMax","angle","PI","cosAngle","cos","sinAngle","sin","index","postMessage"],"version":3,"file":"worker.f94b5f94.js.map"}